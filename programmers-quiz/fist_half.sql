FIRST_HALF 테이블은 아이스크림 가게의 상반기 주문 정보를 담은 테이블입니다.FIRST_HALF 테이블 구조는 다음과 같으며, 
SHIPMENT_ID, FLAVOR, TOTAL_ORDER는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다.

NAME  TYPE  NULLABLE
SHIPMENT_ID INT(N)  FALSE
FLAVOR  VARCHAR(N)  FALSE
TOTAL_ORDER INT(N)  FALSE

CREATE TABLE IF NOT EXISTS FIRST_HALF (
  SHIPMENT_ID INT NOT NULL,
  FLAVOR  VARCHAR(25) NOT NULL PRIMARY KEY,
  TOTAL_ORDER INT NOT NULL
);

-- 테이블 확인
SELECT * FROM FIRST_HALF;

-- 데이터 비우기
TRUNCATE FIRST_HALF;

INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (101, 'chocolate', 3200);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (102, 'vanilla', 2800);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (103, 'mint_chocolate', 1700);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (104, 'caramel', 2600);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (105, 'white_chocolate', 3100);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (106, 'peach', 2450);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (107, 'watermelon', 2150);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (108, 'mango', 2900);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (109, 'strawberry', 3100);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (110, 'melon', 3150);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (111, 'orange', 2900);
INSERT INTO FIRST_HALF (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES (112, 'pineapple', 2900);

ICECREAM_INFO 테이블 구조는 다음과 같으며, FLAVOR, INGREDITENT_TYPE 은 각각 아이스크림 맛, 아이스크림의 성분 타입을 나타냅니다. 
INGREDIENT_TYPE에는 아이스크림의 주 성분이 설탕이면 sugar_based라고 입력되고, 아이스크림의 주 성분이 과일이면 fruit_based라고 입력됩니다. 
ICECREAM_INFO의 기본 키는 FLAVOR입니다. ICECREAM_INFO테이블의 FLAVOR는 FIRST_HALF 테이블의 FLAVOR의 외래 키입니다.

NAME  TYPE  NULLABLE
FLAVOR  VARCHAR(N)  FALSE
INGREDIENT_TYPE VARCHAR(N)  FALSE

CREATE TABLE IF NOT EXISTS ICECREAM_INFO (
  FLAVOR  VARCHAR(25) NOT NULL,
  INGREDIENT_TYPE VARCHAR(25) NOT NULL
);

-- 테이블 확인
SELECT * FROM ICECREAM_INFO;

-- 데이터 비우기
TRUNCATE ICECREAM_INFO;

INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('chocolate', 'sugar_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('vanilla', 'sugar_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('mint_chocolate', 'sugar_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('caramel', 'sugar_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('white_chocolate', 'sugar_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('peach', 'fruit_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('watermelon', 'fruit_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('mango', 'fruit_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('strawberry', 'fruit_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('melon', 'fruit_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('orange', 'fruit_based');
INSERT INTO ICECREAM_INFO (FLAVOR, INGREDIENT_TYPE) VALUES ('pineapple', 'fruit_based');

JULY 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER 은 
각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 7월 아이스크림 총주문량을 나타냅니다. 
JULY 테이블의 기본 키는 SHIPMENT_ID입니다. JULY테이블의 FLAVOR는 FIRST_HALF 테이블의 FLAVOR의 외래 키입니다. 
7월에는 아이스크림 주문량이 많아 같은 아이스크림에 대하여 서로 다른 두 공장에서 아이스크림 가게로 출하를 진행하는 경우가 있습니다. 
이 경우 같은 맛의 아이스크림이라도 다른 출하 번호를 갖게 됩니다.

NAME  TYPE  NULLABLE
SHIPMENT_ID INT(N)  FALSE
FLAVOR  VARCHAR(N)  FALSE
TOTAL_ORDER INT(N)  FALSE

CREATE TABLE IF NOT EXISTS JULY (
  SHIPMENT_ID INT NOT NULL PRIMARY KEY,
  FLAVOR VARCHAR(25) NOT NULL,
  TOTAL_ORDER INT NOT NULL,
  FOREIGN KEY (FLAVOR) REFERENCES FIRST_HALF (FLAVOR)
);

-- 테이블 확인
SELECT * FROM JULY;

-- 데이터 비우기
TRUNCATE JULY;

INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(101, 'chocolate', 520);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(102, 'vanilla', 560);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(103, 'mint_chocolate', 400);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(104, 'caramel', 460);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(105, 'white_chocolate', 350);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(106, 'peach', 500);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(107, 'watermelon', 780);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(108, 'mango', 790);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(109, 'strawberry', 520);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(110, 'melon', 400);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(111, 'orange', 250);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(112, 'pineapple', 200);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(208, 'mango', 110);
INSERT INTO JULY (SHIPMENT_ID, FLAVOR, TOTAL_ORDER) VALUES(209, 'strawberry', 220);

-- 상반기에 판매된 아이스크림의 맛을 총주문량을 기준으로 내림차순 정렬하고 총주문량이 같다면 출하 번호를 기준으로 오름차순 정렬하여 조회하는 SQL 문을 작성해주세요.
SELECT FLAVOR
  FROM FIRST_HALF
 ORDER BY TOTAL_ORDER DESC, SHIPMENT_ID;
 
-- 상반기 동안 각 아이스크림 성분 타입과 성분 타입에 대한 아이스크림의 총주문량을 총주문량이 작은 순서대로 조회하는 SQL 문을 작성해주세요. 
-- 이때 총주문량을 나타내는 컬럼명은 TOTAL_ORDER로 지정해주세요.
SELECT INGREDIENT_TYPE
     , SUM(TOTAL_ORDER) TOTAL_ORDER
  FROM FIRST_HALF FH
  JOIN ICECREAM_INFO II ON II.FLAVOR = FH.FLAVOR
 GROUP BY INGREDIENT_TYPE
 ORDER BY TOTAL_ORDER;
 
-- 상반기 아이스크림 총주문량이 3,000보다 높으면서 아이스크림의 주 성분이 과일인 아이스크림의 맛을 총주문량이 큰 순서대로 조회하는 SQL 문을 작성해주세요.
SELECT FH.FLAVOR 
  FROM FIRST_HALF FH
  JOIN ICECREAM_INFO II ON II.FLAVOR = FH.FLAVOR
 WHERE FH.TOTAL_ORDER >= 3000
   AND II.INGREDIENT_TYPE = 'fruit_based'
 ORDER BY TOTAL_ORDER DESC;
 
-- 7월 아이스크림 총 주문량과 상반기의 아이스크림 총 주문량을 더한 값이 큰 순서대로 상위 3개의 맛을 조회하는 SQL 문을 작성해주세요.
SELECT FH.FLAVOR
  FROM FIRST_HALF FH
  JOIN (SELECT FLAVOR
             , SUM(TOTAL_ORDER) SUM_JULY
          FROM JULY
         GROUP BY FLAVOR) J
    ON FH.FLAVOR = J.FLAVOR
  ORDER BY TOTAL_ORDER+SUM_JULY DESC
  LIMIT 3;
 
