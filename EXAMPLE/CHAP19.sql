SET SERVEROUTPUT ON;
-- 19-1 프로시저 생성
CREATE OR REPLACE PROCEDURE PRO_NOPARAM
IS
    V_EMPNO NUMBER(4) := 7788;
    V_ENAME VARCHAR2(10);

BEGIN
    V_ENAME := 'SCOTT';
    DBMS_OUTPUT.PUT_LINE('V_EMPNO : ' || V_EMPNO);
    DBMS_OUTPUT.PUT_LINE('V_ENAME : ' || V_ENAME);
END;
/

-- 19-2 프로시저 실행
EXECUTE PRO_NOPARAM;

-- 19-3 익명 블록에서 프로시저 실행
BEGIN
    PRO_NOPARAM;
END;
/

-- 19-4 저장된 프로시저 확인 USER_SOURCE 이용
SELECT *
    FROM USER_SOURCE
    WHERE NAME = 'PRO_NOPARAM';
    
-- 19-5 프로시저 확인(SQLPLUS 에서)
SELECT TEXT
FROM USER_SOURCE
WHERE NAME = 'PRO_NOPARAM';
COMMIT;

-- 19-6 프로시저 삭제
DROP PROCEDURE PRO_NOPARAM;

-- 19-7 프로시저 파라미터 지정(매개변수 역할)
CREATE OR REPLACE PROCEDURE PRO_PARAM_IN
(
    PARAM1 IN NUMBER,
    PARAM2 NUMBER,
    PARAM3 NUMBER := 3,
    PARAM4 NUMBER DEFAULT 4
)
IS

BEGIN
    DBMS_OUTPUT.PUT_LINE('PARAM1 : ' || PARAM1);
    DBMS_OUTPUT.PUT_LINE('PARAM2 : ' || PARAM2);
    DBMS_OUTPUT.PUT_LINE('PARAM3 : ' || PARAM3);
    DBMS_OUTPUT.PUT_LINE('PARAM4 : ' || PARAM4);
END;
/

-- 19-8 파라미터 입력 프로시저 사용
EXECUTE PRO_PARAM_IN(1,2,9,8);

-- 19-9 기본값이 지정된 파라미터 입력으로 프로시져 사용
EXECUTE PRO_PARAM_IN(1,2);

-- 19-10 파라미터 적게 입력시 -> 에러
EXECUTE PRO_PARAM_IN(1);

-- 19-11 파라미터 이름 활용 프로시저 실행
EXECUTE PRO_PARAM_IN(PARAM1 => 10, PARAM2 => 20);

-- 19-12 OUT 파라미터 이용 프로시저 생성
CREATE OR REPLACE PROCEDURE PRO_PARAM_OUT
(
    IN_EMPNO IN EMP.EMPNO%TYPE,
    OUT_ENAME OUT EMP.ENAME%TYPE,
    OUT_SAL OUT EMP.SAL%TYPE
)
IS

BEGIN
    SELECT ENAME, SAL INTO OUT_ENAME, OUT_SAL
    FROM EMP
    WHERE EMPNO=IN_EMPNO;

END PRO_PARAM_OUT;
/

-- 19-13 OUT 모드 파라미터 사용
DECLARE
    V_ENAME EMP.ENAME%TYPE;
    V_SAL EMP.SAL%TYPE;
BEGIN
    PRO_PARAM_OUT(7788, V_ENAME, V_SAL);
    DBMS_OUTPUT.PUT_LINE('ENAME : ' || V_ENAME);
    DBMS_OUTPUT.PUT_LINE('SAL : ' || V_SAL);
END;
/

-- 19-14 IN OUT 모드 파라미터 프로시저 생성
CREATE OR REPLACE PROCEDURE PRO_PARAM_INOUT
(
    INOUT_NO IN OUT NUMBER
)
IS

BEGIN
    INOUT_NO := INOUT_NO*2;
END PRO_PARAM_INOUT;
/

-- 19-15 IN OUT 모드 파라미터 사용하기
DECLARE
    NO NUMBER;
BEGIN
    NO := 5;
    PRO_PARAM_INOUT(NO);
    DBMS_OUTPUT.PUT_LINE('NO : ' || NO);
END;
/

-- 19-16 생성할 떄 오류가 발생하는 프로시저
CREATE OR REPLACE PROCEDURE PRO_ERR
IS
    ERR_NO NUMBER;
BEGIN
    ERR_NO =100;
    DBMS_OUTPUT.PUT_LINE('ERR_NO : ' || ERR_NO);
END PRO_ERR;
/

-- 19-17 오류 확인
SHOW ERRORS;
SHOW ERR;
SHOW ERR PROCEDURE PRO_ERR;

-- 19-18 USER_ERRORS 로 오류 확인
SELECT  *
    FROM USER_ERRORS
    WHERE NAME = 'PRO_ERR';
    
-- 19-19 함수 생성
CREATE OR REPLACE FUNCTION FUNC_AFTERTAX
(
SAL IN NUMBER -- 매개변수
)

RETURN NUMBER -- 반환타입

IS 
    TAX NUMBER := 0.05; -- 선언부

BEGIN
    RETURN(ROUND(SAL-(SAL*TAX)));

END FUNC_AFTERTAX;
/

-- 19-20 함수 사용
DECLARE
    AFTERTAX NUMBER;
BEGIN
    AFTERTAX := FUNC_AFTERTAX(3000);
    DBMS_OUTPUT.PUT_LINE('AFTERTAX INCOME : ' || AFTERTAX);
END;
/

-- 19-21 SQL에서 함수 사용하기
SELECT FUNC_AFTERTAX(3000)
FROM DUAL;

-- 19-22 테이블 에 함수 데이터 사용
SELECT EMPNO, ENAME, SAL, FUNC_AFTERTAX(SAL) AS AFTERTAX
FROM EMP;

-- 19-23 함수 삭제
DROP FUNCTION FUNC_AFTERTAX;

-- 19-24 PACKAGE 생성
CREATE OR REPLACE PACKAGE PKG_EXAMPLE
IS
    SPEC_NO NUMBER := 10;
    FUNCTION FUNC_AFTERTAX(SAL NUMBER) RETURN NUMBER;
    PROCEDURE PRO_DEPT(IN_DEPTNO IN DEPT.DEPTNO%TYPE);
    PROCEDURE PRO_EMP(IN_EMPNO IN EMP.EMPNO%TYPE);
END;
/

-- 19-25 PACKAGE 명세 확인하기 USER_SOURCE
SELECT TEXT
    FROM USER_SOURCE
    WHERE TYPE ='PACKAGE'
        AND NAME='PKG_EXAMPLE';
        
-- 19-26 PACKAGE 명세 확인 DESC 조회
DESC PKG_EXAMPLE;

-- 19-27 패키지 본문 설정하기
CREATE OR REPLACE PACKAGE BODY PKG_EXAMPLE

IS
    BODY_NO NUMBER := 10;

    FUNCTION FUNC_AFTERTAX(SAL NUMBER) RETURN NUMBER
    IS
        TAX NUMBER := 0.05;
    BEGIN
        RETURN(ROUND(SAL-(SAL*TAX)));
    END FUNC_AFTERTAX;
    
    PROCEDURE PRO_EMP(IN_EMPNO IN EMP.EMPNO%TYPE)
    IS
        OUT_ENAME EMP.ENAME%TYPE;
        OUT_SAL EMP.SAL%TYPE;
    BEGIN
        SELECT ENAME, SAL INTO OUT_ENAME, OUT_SAL
        FROM EMP
        WHERE EMPNO=IN_EMPNO;
        
        DBMS_OUTPUT.PUT_LINE('ENAME :' || OUT_ENAME);
        DBMS_OUTPUT.PUT_LINE('SAL : ' || OUT_SAL);
    END PRO_EMP;
    
    PROCEDURE PRO_DEPT(IN_DEPTNO IN DEPT.DEPTNO%TYPE)
    IS
        OUT_DNAME DEPT.DNAME%TYPE;
        OUT_LOC DEPT.LOC%TYPE;
    BEGIN
        SELECT DNAME, LOC INTO OUT_DNAME, OUT_LOC
        FROM DEPT
        WHERE DEPTNO= IN_DEPTNO;
        
        DBMS_OUTPUT.PUT_LINE('DNAME : ' || OUT_DNAME);
        DBMS_OUTPUT.PUT_LINE('LOC : ' || OUT_LOC);
    END PRO_DEPT;
END;
/

-- 19-28 프로시저 오버로드
CREATE OR REPLACE PACKAGE PKG_OVERLOAD
IS
    PROCEDURE PRO_EMP(IN_EMPNO IN EMP.EMPNO%TYPE);
    PROCEDURE PRO_EMP(IN_ENAME IN EMP.ENAME%TYPE);
END;
/

-- 19-29 오버로드된 프로시져 작성
CREATE OR REPLACE PACKAGE BODY PKG_OVERLOAD
IS
    PROCEDURE PRO_EMP(IN_EMPNO IN EMP.EMPNO%TYPE)
    IS
        OUT_ENAME EMP.ENAME%TYPE;
        OUT_SAL EMP.SAL%TYPE;
    BEGIN
        SELECT ENAME, SAL INTO OUT_ENAME, OUT_SAL
        FROM EMP
        WHERE EMPNO = IN_EMPNO;
        
        DBMS_OUTPUT.PUT_LINE('ENAME : ' || OUT_ENAME);
        DBMS_OUTPUT.PUT_LINE('SAL ; ' || OUT_SAL);
    END PRO_EMP;
    
    PROCEDURE PRO_EMP(IN_ENAME IN EMP.ENAME%TYPE)
    IS
        OUT_ENAME EMP.ENAME%TYPE;
        OUT_SAL EMP.SAL%TYPE;
    BEGIN
        SELECT ENAME, SAL INTO OUT_ENAME, OUT_SAL
        FROM EMP
        WHERE ENAME = IN_ENAME;
        
        DBMS_OUTPUT.PUT_LINE('ENAME : ' || OUT_ENAME);
        DBMS_OUTPUT.PUT_LINE('SAL : ' || OUT_SAL);
    END PRO_EMP;
    
END;
/

-- 19-30 PACKAGE에 포함된 서브 프로그램 실행
BEGIN
    DBMS_OUTPUT.PUT_LINE('--PKG_EXAMPLE.FUNC_AFTERTAX(3000)--');
    DBMS_OUTPUT.PUT_LINE('AFTER-TAX:' || PKG_EXAMPLE.FUNC_AFTERTAX(3000));
    
    DBMS_OUTPUT.PUT_LINE('--PKG_EXAMPLE.PRO_EMP(7788)--');
    PKG_EXAMPLE.PRO_EMP(7788);
    
    DBMS_OUTPUT.PUT_LINE('--PKG_EXAMPLE.PRO_DEPT(10)--');
    PKG_EXAMPLE.PRO_DEPT(10);
    
    DBMS_OUTPUT.PUT_LINE('--PKG_OVERLOAD.PRO_EMP(7788)--');
    PKG_OVERLOAD.PRO_EMP(7788);
    
    DBMS_OUTPUT.PUT_LINE('--PKG_OVERLOAD.PRO_EMP("SCOTT")--');
    PKG_OVERLOAD.PRO_EMP('SCOTT');
END;
/

-- 19-31 연승용 테이블 생성 EMP_TRG
CREATE TABLE EMP_TRG
    AS SELECT * FROM EMP;
    
-- 19-32 TRIGGER  생성
CREATE OR REPLACE TRIGGER TRG_EMP_NODML_WEEKEND
BEFORE
    INSERT OR UPDATE OR DELETE ON EMP_TRG
    BEGIN
        IF TO_CHAR(SYSDATE, 'DY') IN('토','일','목') THEN
            IF INSERTING THEN
                RAISE_APPLICATION_ERROR(-20000, '주말 사원정보 추가 불가');
            ELSIF UPDATING THEN
                RAISE_APPLICATION_ERROR(-20001, '주말 사원정보 수정 불가');
            ELSIF DELETING THEN
                RAISE_APPLICATION_ERROR(-20002, '주말 사원정보 삭제 불가');
            ELSE
                RAISE_APPLICATION_ERROR(-20003, '주말 사원정보 변경 불가');
            END IF;
        END IF;    
END;
/

-- 19-33,45 평일 날짜로 EMP_TRG 테이블 UPDATE, 금지된 날로 UPDATE
UPDATE EMP_TRG SET SAL=3500 WHERE EMPNO=7788;

-- 19-35 EMP_TRG_LOG 실습용 테이블(DML 실행 저장용)
CREATE TABLE EMP_TRG_LOG(
    TABLENAME VARCHAR2(10),
    DML_TYPE VARCHAR2(10),
    EMPNO NUMBER(4),
    USER_NAME VARCHAR2(30),
    CHANGE_DATE DATE
    );
    
-- 19-36 DML 실행 후 테이블에 로그를 저장하는 트리거
CREATE OR REPLACE TRIGGER TRG_EMP_LOG
AFTER
INSERT OR UPDATE OR DELETE ON EMP_TRG
FOR EACH ROW

BEGIN

    IF INSERTING THEN
        INSERT INTO EMP_TRG_LOG
        VALUES('EMP_TRG','INSER', :NEW.EMPNO,
                SYS_CONTEXT('USERENV','SESSION_USER'), SYSDATE);
                
    ELSIF UPDATING THEN
        INSERT INTO EMP_TRG_LOG
        VALUES('EMP_TRG','UPDATE', :OLD.EMPNO,
                SYS_CONTEXT('USERENV','SESSION_USER'), SYSDATE);
                
    ELSIF DELETING THEN
        INSERT INTO EMP_TRG_LOG
        VALUES('EMP_TRG', 'DELETE', :OLD.EMPNO,
                SYS_CONTEXT('USERENV','SESSION_USER'), SYSDATE);

    END IF;
END;
/

-- 19-37 EMP_TRG INSERT -- 19-38 COMMIT;
INSERT INTO EMP_TRG
    VALUES(9999, 'TestEMP', 'CLERK', 7788, TO_DATE('2018-03-03', 'YYYY-MM-DD'), 1200, NULL, 20);

COMMIT;

-- 19-39 INSERT 확인
SELECT * FROM EMP_TRG;

-- 19-40 TRIGGER LOG 확인
SELECT*FROM EMP_TRG_LOG;
    
-- 19-41,2 UPDATE 실행 COMIMT;
UPDATE EMP_TRG
    SET SAL=1300
    WHERE MGR=7788;

COMMIT;
    
-- 19-43 TRIGGER 정보, USER_TRIGGERS
SELECT TRIGGER_NAME, TRIGGER_TYPE, TRIGGERING_EVENT, TABLE_NAME, STATUS
    FROM USER_TRIGGERS;